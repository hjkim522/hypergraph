제 1 장 서  론

1.1 연구 배경
하이퍼그래프는 일반화된 그래프로서 하나의 에지 안에 다수의 노드 그리고 다른 에지도 포함할 수 있는 그래프이다. 보통의 그래프에서 에지는 두 개의 노드만을 연결하는데 반하여, 하이퍼그래프에서는 여러 개의 노드를 연결할 수 있고 이때 여러 개의 노드가 연결된 에지를 하이퍼에지라고 한다. 하이퍼에지에 방향성이 있는 경우도 있는데, 이 때 하이퍼에지는 다수의 소스 노드와 다수의 타겟 노드를 연결하는 역할을 한다.
다수의 노드 간에 관계가 있음을 나타냄으로서 보통 그래프로 나타낼 수 없는 형태의 데이터도 모델링 할 수 있다. 예를 들어 다수의 화합물이 모두 존재해야 활성화되는 단백질 데이터를 모델링 할 경우에 다수의 화합물을 하나의 소스 집합으로 하고 단백질을 타겟 노드로 하는 하이퍼에지를 생성하면 된다. 하이퍼그래프는 생물정보학 이외에도 인공지능 등의 분야에서 유용하게 사용되고 있다.
하이퍼그래프를 이용하여 모델링된 데이터베이스에서 소스 노드로부터 닿을 수 있는 타겟 노드를 검색하거나, 혹은 타겟 노드를 지정하면 필요한 소스 노드를 찾아주는 질의를 생각해 볼 수 있다. 소스 노드를 지정하고 타겟 노드를 찾는 질의를 정방향 지식 추론이라 하고, 타겟 노드를 지정하고 소스 노드를 찾는 질의를 역방향 지식 추론이라 정의한다. 하이퍼에지의 방향과 추론의 방향이 일치하는 경우 정방향, 반대인경우 역방향이 된다. 정방향 지식 추론은 하이퍼그래프 탐색을 통해 쉽게 추론해 낼 수 있지만, 역방향 지식 추론은 에지 역방향으로 탐색하기에는 경우의 수가 너무 많다. 실제로 역방향 지식 추론은 NP-Hard 문제이며, 본 연구에서는 역방향 지식 추론을 위한 효과적인 인덱싱 방법인 MSS-index를 제시한다.
MSS-Index는 각 노드에 도착할 수 있는 최적 소스 집합을 미리 계산하여 인덱싱하는 방법이며, MSS-Index를 이용하면 역방향 지식 추론 질의를 빠르게 수행할 수 있다. 

1.2 관련 연구 동향
하이퍼그래프는 1970년대 C. Berge가 이론을 정립했고, And-Or-Graph 혹은 또 무슨 그래프라는 유사한 이름을 많이 연구되어 왔다. 내용은 잘 모르는데, 하이퍼그래프 탐색과 관련해서 최단경로 찾기, 혹은 최단경로를 찾을 때 일종의 코스트 함수를 이용하는 방법은 폴리노미얼 타임 내에 해결할 수 있는 문제이기 때문에 이 방향으로 많이 연구되었다. 하이퍼그래프를 데이터베이스와 접목한 것은 hypergraphdb 가 있으나 그래프 데이터베이스 내에서 자유로운 탐색이나 추론을 지원하지 않는다.

1.3 연구목적
하이퍼그래프를 기반으로 한 데이터에서 지식을 추론하기 위한 연구이다. 소스 노드로부터 닿을 수 있는 타겟 노드를 반환하는 정방향 추론, 타겟노드에 도착할 수 있는 소스 노드를 찾는 역방향 추론을 수행하는 알고리즘을 개발하고 빠르게 수행될 수 있도록 인덱스를 구성하는것이 본 연구의 목표이다.

1.4 논문의 구성
제 2 장에서는 하이퍼그래프의 개념 및 지식 추론에 대해 정의하고 설명한다. 또한 정방향 지식 추론과 역방향 지식 추론을 해결하는 기본적인 알고리즘을 제시한다. 제 3 장에서는 역방향 지식 추론을 빠르게 수행하기 위한 인덱스 방법인 MSS-Index를 제안하고 구축하는 방법을 제시한다. 또한 하이퍼그래프에 노드나 하이퍼에지가 추가되었을 때 MSS-Index를수정하는 방법을 설명하고, 인덱스가 너무 큰 경우에 인덱스를 decompose(한글로뭐지)하고 재구축하는 방법을 제시한다. 제 4 장에서는 MSS-Index의 구현 방법과 실험 결과에 대해 설명한다.

제 2 장 하이퍼그래프의 개념 및 지식 추론
2.1 하이퍼그래프
하이퍼그래프는 노드와 하이퍼에지로 구성된 그래프이다.

정의1. 하이퍼그래프
하이퍼그래프 H = <V, E>는 노드 집합 V와 하이퍼에지 집합 E의 쌍으로 정의된다.

정의2. 하이퍼에지
하이퍼에지

수학적으로 하이퍼에지는 노드와 하이퍼 에지 모두를 포함할 수 있다. 본 논문에서는 실제 상황에 적합한 모델을 선택하여 정의하고 이 모델을 기반으로 지식 추론 및 탐색을 수행할 예정이다. 

정의3. 유향 하이퍼그래프
유향 하이퍼그래프 H = <V, E>는 방향성이 있는 하이퍼그래프 이며 노드 집합 V와 유향 하이퍼에지의 집합 E의 쌍으로 정의된다. 보통의 하이퍼그래프와는 다르게 하이퍼에지에 방향성을 추가하여 좀 더 많은 정보를 표현할 수 있다.

정의4. 유향 하이퍼에지 (Directed Hyperedge)
유향 하이퍼에지 e = <S, T>는 소스 노드 집합 S와 타겟 노드 집합 T의 쌍으로 정의된다. S와 T 모두 V의 서브셋이며, 이 정의에서는 하이퍼 에지는 에지를 포함할수는 없다. 하지만 데이터 모델링에는 적합한 방법이라고 생각된다. 그동안 연구되었던 논문에서 B-arc를 기본이 되는 하이퍼에지로 사용한다.

기존 연구에서는 하이퍼그래프의 패스를 두 가지로 나누어 설명하고 있다. 일반적인 그래프에서와 마찬가지로, 노드:에지:노드:에지가 반복되는 패스가 있는 방면에 하이퍼그래프의 의미에 좀 더 적합한 패스인 하이퍼패스를 정의하여 사용할 수도 있다. 노드, 에지가 단순 반복되는 패스 또한 쓸곳은 있긴 있는데 암튼 하이퍼에지의 의미를 모든 소스 노드가 탐색되어야만 타겟 노드 t로 진행할 수 있는 constraint (한글로 뭐지)를 부여하여 탐색 및 패스를 정의할 수 있고, 하이퍼패스의 정의는 아래와 같다.

하이퍼그래프에서의 패스 = B-패스
하이퍼그래프에서의 패스는 그래프에서의 패스와는 달리 일종의 트리로 정의된다.
정의5. 하이퍼패스
어떤 소스 노드 집합 S 에서 t로 가는 하이퍼패스 T(S,t)는 다음과 같이 재귀적으로 정의된다. 루트 노드로 가장 마지막 하이퍼에지인 <X, t>를 루트 노드로 하는 트리이며 이 루트 노드는 S 에서 X의 모든 요소로 도착하는 패스인 T(S,xi)를 서브 트리로 갖는다.

정의6. 다중 타겟 하이퍼패스
정의5에 의하면 하이퍼패스는 단일 타겟 노드만 가질 수 있지만, 이 정의를 확장하여 다수의 타겟 노드를 사용할 수 있도록 한다. 어떤 소스 노드 집합 S에서 T로 가는 하이퍼패스 T(S,T) 를 나타내기 위해서 가상의 하이퍼에지 <T,t> 를 추가하고 이를 루트 노드로 하는 트리를 다중 타겟 하이퍼 패스라고 정의한다. 즉 단일 타겟 t에 도착하는 하이퍼패스는 다중 타겟 T에 도착하는 하이퍼 패스가 된다.

하이퍼그래프 탐색
하이퍼에지의 의미(semantic)를 지키는 탐색 B-traversal 은 다음과 같이 큐를 이용해 구현할 수 있다. 하이퍼에지를 탐색에 이용하기 위해서는 해당 하이퍼에지의 모든 소스 노드들이 먼저 방문되었어야 한다. 알고리즘1은 우선 탐색을 시작할 초기 노드 혹은 초기 노드 집합을 큐에 넣는 것으로 시작된다. 큐에 삽입되는 노드들은 이미 방문된 노드들이라고 표시되며, 앞으로 하이퍼에지는 모든 소스 노드가 방문된 하이퍼에지만 사용해서 탐색을 이어나간다. 큐에 들어있는 노드 중에서 하나의 노드 v 를 반환한다. v에서 다른 노드들로 향하는 outgoing 하이퍼에지들, 즉 fstar(v) 에 대하여, 모든 소스 노드의 방문이 끝난 하이퍼에지인지 검사한다. 모든 소스 노드가 방문된 하이퍼에지의 경우, 연결된 타겟 노드들을 방문하고, 또 탐색을 이어가기 위해 방문한 타겟 노드들을 큐에 삽입한다. 더 이상 사용할 수 없는 하이퍼에지가 없는 경우 큐에 들어가는 노드가 없고, 큐에서 모든 노드가 반환되면 탐색은 끝이 난다.

2.2 정방향 지식 추론
정방향 지식 추론은 주어진 소스 노드로부터 닿을 수 있는 타겟 노드들을 찾는 질의의며 아래와 같이 정의된다.

정의1. 정방향 지식 추론
하이퍼그래프 H = <V, E> 가 주어졌을 때, 시작 노드 집합 VS로부터 탐색할 수 있는 모든 타겟 노드를 찾는다. 이 때 타겟 노드는 특정 라벨 LT를 가지고 있어야 한다.

정방향 지식 추론은 하이퍼그래프 탐색 알고리즘을 이용하여 쉽게 구현할 수 있다.

2.3 역방향 지식 추론
역방향 지식 추론은 주어진 타겟 노드들에 도착할 수 있는 최소의 소스 노드 집합을 찾는 문제이다.

정의2. 역방향 지식 추론
라벨 유향 하이퍼그래프 H = <V, E, L, M> 에서, 특정 노드 집합 T 에 도착할 수 있는 S 를 찾는다. 이 때 조건은 (a)S 는 V 의 부분집합이어야 하고 (b) S의 모든 노드들은 레이블 LS 를 가지고 있어야 하며, (c) S는 최소의 크기를 가지고 있어야 한다.

역방향 지식 추론은 정방향 지식 추론과는 다르게 쉽게 풀 수 없는데, 역방향 지식 추론 문제가 NP-Hard이기 때문이다. 증명은 SetCover를 역방향 지식 추론 문제로 reduce하여 보일 수 있다. (설명)

역방향 지식 추론을 위한 직관적인 해결 알고리즘으로는 아래와 같은 방법을 생각해 볼 수 있다. 우선 주어진 타겟 노드 집합 T에서부터 하이퍼에지의 역방향으로 탐색을 시작하는데, 이 때 어떤 노드에 도착했을 때 그 노드로 들어오는 에지 bstar(v) 를 모드 방문하면 되고, 그 에지의 소스 노드들에 모두 방문해야 한다. 더 이상 방문할 노드가 없는 경우 방문된 노드 중에서 라벨 LS 를 갖는 노드들만을 골라내고 이를 VS 라 하자. <VS, T> VS 에서 T로 가는 하이퍼에지가 존재하는 경우, VS의 서브셋 안에 최적해가 있다. VS, T 로 가는 하이퍼에지가 없는 경우에는 T 는 라벨 LS 를 갖는 노드들에서부터 탐색이 불가능한 노드들이 된다. (증명생략), 따라서 VS의 모든 서브셋으로부터 T 로 가는 하이퍼패스를 검사해보고, 서브셋중에 가장 크기가 작은 집합을 선택하면 최적해를 찾을 수 있다.

실제로 모든 서브셋을 검사하기에는 시간이 너무 오래 소모되므로, 역방향 탐색을 하면서 모든 bstar(v) 를 방문하는 것이 아니라 bstar(v) 인커밍 엣지 중에서 하나만 선택하는 방법을 생각해 볼 수 있다. 에지 중에서 하나만 선택하여 역방향 탐색을 해서 얻을 수 있는 소스 집합을 S라 하자. 그러면 <S, T>는 존재하지만 S가 최적해가 아닐 수도 있다. 즉 에지를 선택하면서 모든 에지를 돌아가며 한번씩 선택해보면, S 에서 T로 가는 모든 패스들을 탐색해 볼 수 있고, 이 모든 패스틀 중에서 소스집합의 크기가 가장 작은 소스집합을 선택하면 최적해를 찾을 수 있다. 이 방법을 baseline approach로 하여 이후 실험을 진행할 예정인다. 이 방법도 탐색해야 할 가짓수가 너무 많기 때문에 대용량 데이터에서는 사용할 수 없는 방법이다. 역방향 지식 추론을 잘 수행할 수 있도록 미리 닿을 수 있는 노드들을 계산하는 방법인 MSS-Index를 제안하려 한다.

제 3 장 MSS-Index
MSS-Index는 역방향 지식 추론을 위하여 어떤 노드에 닿을 수 있는 최적소스노드 집합(minimal source set)을 모두 계산해 두는 방법이다. 단일 노드의 최적소스노드 집합을 모두 계산해 두면, 다중 노드의 역방향 지식 추론에 대하여, 계산된 최적소스노드 집합들을 모두 cartesian 곱을 구하고, 그 중에서 가장 크기가 작은 집합을 선택하면 역방향 지식 추론의 값을 쉽게 낼 수 있다. 또한 에지의 역방향으로 탐색하는 것보다, MSS-Index를 구성하는 방법이 비교적 간단하여 에지의 역방향으로 탐색하는 것보다 훨씬 효율적으로 역방향 지식 추론을 수행할 수 있다.

MSS-Index에 대해 설명하기에 앞서 우선 MSS(Minimal source set) 최적소스노드 집합에 대해 정의한다.
정의1. 최적소스노드 집합 (최적집합) 
최적소스란 일종의 노드 집합으로, 타겟 노드 t 까지 하이퍼패스가 존재하는 소스 집합을 일컷는다. 이 때 최적소스 S 에서 하나의 요소만 제거하더라고 하이퍼패스를 찾을 수 없는 집합을 최적 집합이라고 정의한다. 예를 들어 <abc, d> 라는 하이퍼에지 하나를 갖는 그래프 H를 생각해보자. 소스 집합 abc에서 타겟 노드 d까지 패스는 <abc, d> 에지를 루트로 하는 트리가 된다. 하지만 이 때 abc 중에서 한 요소만 없더라고 <abc, d> 하이퍼에지를 사용할 수 없기 때문에 ab, ac, bc 등은 노드 d 의 최적 노드 집합이 될 수 없다.
또한 abcd 같은 경우에는 d 노드가 없더라고 d 노드에 도달할 수 있기 때문에 abcd 또한 최적 노드집합이라 할 수 없다.

정의2. MSS
특정 노드 t의 최적소스를 모두 모아둔 것을 mss 라고 정의한다.

렘마1. 최적소스노드 집합에 S 가 존재하면, S 의 슈퍼셋, S 의 서브셋은 MSS 에 포함될 수 없다. 증명) 생략

정의3. MSS의 재귀적 정의 - 재귀적 정의 아닌듯.....
MSS는 위 정의 외에도 하이퍼에지의 의미를 이용하여 재귀적으로 정의할수도 있다. 우선 노드의 mss는 다음과 같이 노드로 들어오는 모든 에지들의 mss를 합하고 그중에서 최적집합만을 선택하면서 계산할 수 있고, 다음과같이 정의 가능하다.
이 때 에지의 경우 다음과 같이 정의할 수 있는데, 에지의 모든 소스노드들의 mss(v) 가 계산되어 있다면 mss의 카테시안 곱을 구하여 최적집합을 선택하여 계산할 수 있다.

전체 그래프에서 위 규칙을 이용하여 시작 라벨 LS 가 붙은 노드들 부터 시작해서 빌드 가능한다.

먼저 문제를 단순하게 정의하기 위해 근데 acyclic HG인 경우부터 생각한다. acyclic hg의 경우 topological sort가 가능하며, 해당 에지릐 mss를 계산하기 이전에 모든 소스 노드의 mss를 먼저 계산할 수 있다. 따라서 간단하게 빌드 가능

하지만 cycle 이 있는 경우에 이미 mss가 계산된 와 이거 글로 쓰는거 힘드ㄴ네.... 노드로 에지가 연결될 수 있고, 이 때 해당 노드의 mss 뿐만이 아니라 타겟 노드와 연결된 다른 노드들의 mss도 다시 계산해야 한다. 따라서 이 재 계산을 최소화하기 위해 prioiryt quee 를 사용하여, 가장 계산되지 않은 inedge 의 수가 적은 노드부터 mss를 계산하도록 했다.

mss 를 빌드하면서 빌드 순서라던가 optimize 가능할텐데, 기초 연구라서 수행하지는 않았다.

기존의 하이퍼그래프에 노드나 에지가 추가되는 경우 mss 는 다음과 같이 수정할 수 있다. 먼저 노드가 추가되는경우를 생각해본다. 노드에 out edge 가 없다면, inedge 로부터 mss 를 계산하여 삽입하면 된다. 하지만 outedge가 있다면 inedge 로부터 mss 를 계산한 이후에, 나가는 에지들과 연결된 타겟 노드들의 mss를 변경해 주어야 하고, 이 때 이 변경은 더이상 mss가 변하지 않는 노드에 이를때까지 계속 propagte 되어야 한다.

노드의 삭제도 마찬가지로, 노드 삭제로 인해 영향을 받는 노드들로부터 mss를 다시 계산해야 하며, 더이상 변하지 않을때까지 계속 propagate 해야 한다. 
mss 의 수정 방법은 최악의 경우 그래프 전체 노드를 업데이트 하게 되지만, 실제 데이터셋에서는 local 하게 일어날 것임을 기대하며, 또한 화합물 데이터베이스의 경우 실제로 추가 삭제가 빈번하지 않을 것이기 때문에 크게 문제가 되지 않을 것 같다.

MSS의 크기는 계산이 진행될수록 점점 커지게 된다. cart와 union 을 수행하기 때문이고, 소스 노드가 합쳐지지 않으면 계속 늘어나게 되는데, 이 때는 mss 계산을 다시 시작하는 방법을 사용한다. 지금까지 계산된 mss를 저장하고, 해당 노드가 decomposed 되었음을 표시한 이후 해당 노드가 LS 를 가지고 있지 않더라고, 가상의 startable set 이라 가정하고 그 노드의 아이디를 이용해 이후 계산을 수행한다. mss의 크기를 크게 줄일 수 있고 게산도 빠르게 수행할 수 있다.

이후 실제로 역방향 지식 추론 질의가 들어왔을 때 decomposed node가 mss에 들어있다면, 저장된 mss로 대치하는 방법을 통해 복구 가능하다. acyclic graph 인 경우에 decomposed 된 mss 간에도 cycle 이 존재하지 않으므로 deterministic 하게 reconstruction 가능하지만, cycle 이 있는 경우에는 특수하게 처리해야 한다. 진짜>?
우선 mss에 decomposed node a* 가 존재한다고 가정하자, 그러면 mss 는 다음과 같이 두 집합으로 나눌 수 있는데, 엘리먼트로 a*를 가지는 요소들의 집합과, 가지지 않는 요소들의 집합이다. a* 를 가지는 요소들을 따로 모아서 다음과 같이 reformulate 할 수 있다. a cratesian B, 즉 저장된 a의 mss를 가져와서 B와 카테시안곱을 하면 원래의 답을 복구해 낼 수 있다. 와 이거 써야되는거 양이 엄청난데? 과연 쓸 수 있을것인가...

제 4 장 구현 및 실험결과
하이퍼그래프를 지원하는 데이터베이스가 없기 때문에 일반 그래프데이터베이스를 사용하여 구현했다. neo4j를 사용하여 구현했다. 하이퍼 에지 대신의 가상의 하이퍼에지를 대신하는 노드를 삽입하는 방법을 이용했다. 즉 가상-하이퍼노드 h를 삽입하고, 소스 S 와 모드 에지를 연결, 소스 t 와 모두 에지를 연결하는 방법을 통해 모델링했다. (좀더자세히설명?)
탐색 및 mss계산에서도 가상 하이퍼노드 h를 하이퍼 에지 대신에 사용했다.

데이터셋은 랜덤하게 생성한 하이퍼그래프와, 실제 생체 데이터 CODA를 이용해 실험했다.




